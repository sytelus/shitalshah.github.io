<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Uncategorized | Shital Shah</title>
    <link>http://shitalshah.com/categories/uncategorized/</link>
      <atom:link href="http://shitalshah.com/categories/uncategorized/index.xml" rel="self" type="application/rss+xml" />
    <description>Uncategorized</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>(C) Shital Shah. All rights reserved.</copyright><lastBuildDate>Sun, 05 Jun 2016 09:24:38 +0000</lastBuildDate>
    <image>
      <url>http://shitalshah.com/img/shitalshah.jepg</url>
      <title>Uncategorized</title>
      <link>http://shitalshah.com/categories/uncategorized/</link>
    </image>
    
    <item>
      <title>Writing Generic Container Functions in C&#43;&#43;11</title>
      <link>http://shitalshah.com/p/writing-generic-container-function-in-c11/</link>
      <pubDate>Sun, 05 Jun 2016 09:24:38 +0000</pubDate>
      <guid>http://shitalshah.com/p/writing-generic-container-function-in-c11/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s say we want to write function to append one vector to another. It can be done like,&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
void append(Vector&amp;lt;T&amp;gt;&amp; to, const Vector&amp;lt;T&amp;gt;&amp; from)
{
    to.insert(to.end(), from.begin(), from.end());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One problem with this approach is that we can only use this function with Vector. So what about all other container types? In languages such as C#, we have IEnumerable&lt;T&gt; that simplifies lot of things but with C++ templates are duck typed and it takes bit more to make above function generic for various container types. Another quick and dirty route is this:&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;template&amp;lt;typename Container&amp;gt;
void append(Container&amp; to, const Container&amp; from)
{
    to.insert(to.end(), from.begin(), from.end());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem with this approach is that any class with begin() and end() will now qualify for this call. In fact, just in case someone has class with these methods which actually isn&amp;rsquo;t implemented as iterator, you can get some nasty surprises. A simple modification is to make sure we call begin() and end() from std namespace instead of the ones defined on class:&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;template&amp;lt;typename Container&amp;gt;
void append(Container&amp; to, const Container&amp; from)
{
    using std::begin;
    using std::end;
    to.insert(end(to), begin(from), end(from));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sure, this is better but wouldn&amp;rsquo;t it be nice if can we restrict the types passed on to this function to only those which strictly behaves like STL containers? Enter type traits! First, we need to define SFINAE type trait for containers. Fortunately Louis Delacroix who developed &lt;a href=&#34;http://louisdx.github.io/cxx-prettyprint/&#34; target=&#34;_blank&#34;&gt;prettyprint library&lt;/a&gt; has already fine tuned this code extensively. Below is mostly his code with a my slight modification that allows to pass it through GCC strict mode compilation. This is lot of code so I would usually put this in a separate file, say, type_utils.hpp, so you can use it for many generic container methods:&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;#ifndef commn_utils_type_utils_hpp
#define commn_utils_type_utils_hpp

#include &amp;lt;type_traits&amp;gt;
#include &amp;lt;valarray&amp;gt;

namespace common_utils { namespace type_utils {
    //from: https://raw.githubusercontent.com/louisdx/cxx-prettyprint/master/prettyprint.hpp
    //also see https://gist.github.com/louisdx/1076849
    namespace detail
    {
        // SFINAE type trait to detect whether T::const_iterator exists.

        struct sfinae_base
        {
            using yes = char;
            using no  = yes[2];
        };

        template &amp;lt;typename T&amp;gt;
        struct has_const_iterator : private sfinae_base
        {
        private:
            template &amp;lt;typename C&amp;gt; static yes &amp; test(typename C::const_iterator*);
            template &amp;lt;typename C&amp;gt; static no  &amp; test(...);
        public:
            static const bool value = sizeof(test&amp;lt;T&amp;gt;(nullptr)) == sizeof(yes);
            using type =  T;

            void dummy(); //for GCC to supress -Wctor-dtor-privacy
        };

        template &amp;lt;typename T&amp;gt;
        struct has_begin_end : private sfinae_base
        {
        private:
            template &amp;lt;typename C&amp;gt;
            static yes &amp; f(typename std::enable_if&amp;lt;
                std::is_same&amp;lt;decltype(static_cast&amp;lt;typename C::const_iterator(C::*)() const&amp;gt;(&amp;C::begin)),
                             typename C::const_iterator(C::*)() const&amp;gt;::value&amp;gt;::type *);

            template &amp;lt;typename C&amp;gt; static no &amp; f(...);

            template &amp;lt;typename C&amp;gt;
            static yes &amp; g(typename std::enable_if&amp;lt;
                std::is_same&amp;lt;decltype(static_cast&amp;lt;typename C::const_iterator(C::*)() const&amp;gt;(&amp;C::end)),
                             typename C::const_iterator(C::*)() const&amp;gt;::value, void&amp;gt;::type*);

            template &amp;lt;typename C&amp;gt; static no &amp; g(...);

        public:
            static bool const beg_value = sizeof(f&amp;lt;T&amp;gt;(nullptr)) == sizeof(yes);
            static bool const end_value = sizeof(g&amp;lt;T&amp;gt;(nullptr)) == sizeof(yes);

            void dummy(); //for GCC to supress -Wctor-dtor-privacy
        };

    }  // namespace detail

    // Basic is_container template; specialize to derive from std::true_type for all desired container types

    template &amp;lt;typename T&amp;gt;
    struct is_container : public std::integral_constant&amp;lt;bool,
                                                        detail::has_const_iterator&amp;lt;T&amp;gt;::value &amp;&amp;
                                                        detail::has_begin_end&amp;lt;T&amp;gt;::beg_value  &amp;&amp;
                                                        detail::has_begin_end&amp;lt;T&amp;gt;::end_value&amp;gt; { };

    template &amp;lt;typename T, std::size_t N&amp;gt;
    struct is_container&amp;lt;T[N]&amp;gt; : std::true_type { };

    template &amp;lt;std::size_t N&amp;gt;
    struct is_container&amp;lt;char[N]&amp;gt; : std::false_type { };

    template &amp;lt;typename T&amp;gt;
    struct is_container&amp;lt;std::valarray&amp;lt;T&amp;gt;&amp;gt; : std::true_type { };

    template &amp;lt;typename T1, typename T2&amp;gt;
    struct is_container&amp;lt;std::pair&amp;lt;T1, T2&amp;gt;&amp;gt; : std::true_type { };

    template &amp;lt;typename ...Args&amp;gt;
    struct is_container&amp;lt;std::tuple&amp;lt;Args...&amp;gt;&amp;gt; : std::true_type { };

}}  //namespace
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can use these traits to enforce what types gets accepted in to your generic function:&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;#include &#34;type_utils.hpp&#34;

template&amp;lt;typename Container&amp;gt;
static typename std::enable_if&amp;lt;type_utils::is_container&amp;lt;Container&amp;gt;::value, void&amp;gt;::type
append(Container&amp; to, const Container&amp; from)
{
    using std::begin;
    using std::end;
    to.insert(end(to), begin(from), end(from));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Much better!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to use Windows network share from domain joined machine on Linux</title>
      <link>http://shitalshah.com/p/how-to-use-windows-network-share-from-domain-joined-machine-on-linux/</link>
      <pubDate>Fri, 03 Jun 2016 21:22:15 +0000</pubDate>
      <guid>http://shitalshah.com/p/how-to-use-windows-network-share-from-domain-joined-machine-on-linux/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m seeing lot of websites with bit outdated or incomplete instructions. So here are the full steps that works for Ubuntu 14 for mounting Windows network file share on Ubuntu through active directory domain account:&lt;/p&gt;

&lt;p&gt;First you need to install cifs-utils. Check if you already have it:&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;dpkg -l cifs-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If not, just install it:&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;sudo apt-get install cifs-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can mount Windows shares anywhere but /mnt is generally preferred. Another often used location is /media but in modern environments /mnt is more preferred for things that users mount manually while /media is more preferred for things that system would mount for you. Regardless, you should create a folder where the content of your share will appear. Run following command to do that:&lt;/p&gt;

&lt;p&gt;Note: In this guide, replace ALL_CAPS words with values you want.&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;mkdir -p /mnt/FOLDER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the mount command:&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;sudo mount -t cifs //SERVER/FOLDER /mnt/FOLDER -o username=USER,domain=DOMAIN,iocharset=utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We set iocharset to utf8. This is optional but better than default charset ISO 8859-1 that Linux uses for mount.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Some websites uses filemod/dirmode to 777 (i.e. grant all permissions). This is usually not necessary. &lt;/ol&gt;
That&amp;rsquo;s it! If you need to unmount share then run the command,&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;sudo umount //SERVER/FOLDER
&lt;/code&gt;&lt;/pre&gt;
    

&lt;p&gt;One problem is that, you will need to run mount command every time after you restart again. While there are ways to connect network shares at startup, they often involve storing your passwords and not recommended. So usually I would just add a line in my ~/.bash-aliases file like this:&lt;/p&gt;

&lt;pre class=&#34;code-block&#34;&gt;&lt;code&gt;alias mountshare=&#39;sudo mount -t cifs //SERVER/FOLDER /mnt/FOLDER -o username=USER,domain=DOMAIN,iocharset=utf8&#39;
&lt;/code&gt;&lt;/pre&gt;
    

&lt;p&gt;So next time when I need share, I just type &lt;code&gt;mountshare&lt;/code&gt; on command line.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
